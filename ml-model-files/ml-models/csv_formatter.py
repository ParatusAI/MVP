# csv_formatter.py
import pandas as pd
import numpy as np
from pathlib import Path

class CsPbBr3DatasetFormatter:
    """
    Formats the CsPbBr3 synthesis dataset into a clear CSV with labeled X and Y columns
    for machine learning training.
    """
    
    def __init__(self):
        # Define clear column mappings
        self.x_features = [
            'cs_flow_rate',      # Input parameter 1
            'pb_flow_rate',      # Input parameter 2  
            'temperature',       # Input parameter 3
            'residence_time'     # Input parameter 4
        ]
        
        self.y_targets = [
            'plqy',             # Primary target: Photoluminescence Quantum Yield
            'emission_peak',    # Secondary target: Emission wavelength (nm)
            'fwhm',            # Secondary target: Full Width Half Maximum
            'quality_class'    # Classification target: excellent/good/fair/poor
        ]
    
    def load_generated_data(self, filename='my_training_data_2000.csv'):
        """Load the dataset generated by the CsPbBr3DataGenerator"""
        try:
            df = pd.read_csv(filename)
            print(f"âœ… Successfully loaded {len(df)} samples from {filename}")
            return df
        except FileNotFoundError:
            print(f"âŒ File {filename} not found. Please run the data generator first.")
            return None
    
    def create_ml_formatted_csv(self, df, output_filename='cspbbr3_ml_dataset.csv'):
        """
        Create a properly formatted CSV with clear X and Y column labels
        """
        # Create formatted dataframe
        formatted_df = pd.DataFrame()
        
        # Add X features (input parameters) with clear labels
        print("ğŸ“Š Formatting X features (input parameters):")
        for i, feature in enumerate(self.x_features, 1):
            col_name = f"X{i}_{feature}"
            formatted_df[col_name] = df[feature]
            print(f"   {col_name}: {df[feature].min():.2f} - {df[feature].max():.2f}")
        
        # Add Y targets (output properties) with clear labels  
        print("\nğŸ¯ Formatting Y targets (output properties):")
        for i, target in enumerate(self.y_targets, 1):
            if target == 'quality_class':
                # Convert categorical to numerical for Y4
                quality_map = {'poor': 0, 'fair': 1, 'good': 2, 'excellent': 3}
                col_name = f"Y{i}_{target}_encoded"
                formatted_df[col_name] = df[target].map(quality_map)
                # Also keep original categorical
                formatted_df[f"Y{i}_{target}_categorical"] = df[target]
                print(f"   {col_name}: {formatted_df[col_name].min()} - {formatted_df[col_name].max()} (encoded)")
            else:
                col_name = f"Y{i}_{target}"
                formatted_df[col_name] = df[target]
                print(f"   {col_name}: {df[target].min():.3f} - {df[target].max():.3f}")
        
        # Save formatted dataset
        formatted_df.to_csv(output_filename, index=False)
        print(f"\nğŸ’¾ Saved formatted dataset to: {output_filename}")
        
        return formatted_df
    
    def create_separate_xy_files(self, df, prefix='cspbbr3'):
        """
        Create separate X.csv and Y.csv files for clear separation
        """
        # Create X matrix (features)
        X_df = pd.DataFrame()
        for i, feature in enumerate(self.x_features, 1):
            X_df[f"X{i}_{feature}"] = df[feature]
        
        # Create Y matrix (targets)
        Y_df = pd.DataFrame()
        for i, target in enumerate(self.y_targets, 1):
            if target == 'quality_class':
                quality_map = {'poor': 0, 'fair': 1, 'good': 2, 'excellent': 3}
                Y_df[f"Y{i}_{target}_encoded"] = df[target].map(quality_map)
            else:
                Y_df[f"Y{i}_{target}"] = df[target]
        
        # Save separate files
        x_filename = f"{prefix}_X_features.csv"
        y_filename = f"{prefix}_Y_targets.csv"
        
        X_df.to_csv(x_filename, index=False)
        Y_df.to_csv(y_filename, index=False)
        
        print(f"ğŸ“ Created separate files:")
        print(f"   Features: {x_filename} ({X_df.shape[1]} columns)")
        print(f"   Targets:  {y_filename} ({Y_df.shape[1]} columns)")
        
        return X_df, Y_df
    
    def create_data_dictionary(self, filename='data_dictionary.txt'):
        """
        Create a comprehensive data dictionary explaining all columns
        """
        dictionary = """
CsPbBr3 Synthesis Dataset - Data Dictionary
==========================================

INPUT FEATURES (X variables):
-----------------------------
X1_cs_flow_rate:    Cesium precursor flow rate (mL/min)
                    Range: 0.5 - 2.2 mL/min
                    Physical meaning: Controls Cs:Pb stoichiometry

X2_pb_flow_rate:    Lead precursor flow rate (mL/min)  
                    Range: 0.6 - 1.8 mL/min
                    Physical meaning: Controls Pb availability

X3_temperature:     Reaction temperature (Â°C)
                    Range: 100 - 200Â°C
                    Physical meaning: Controls nucleation/growth kinetics

X4_residence_time:  Reaction residence time (seconds)
                    Range: 60 - 250 seconds
                    Physical meaning: Time for crystal formation

OUTPUT TARGETS (Y variables):
----------------------------
Y1_plqy:           Photoluminescence Quantum Yield (fraction)
                   Range: 0.15 - 0.92
                   Target: Maximize (>0.80 excellent, >0.60 good)

Y2_emission_peak:  Emission wavelength peak (nm)
                   Range: 505 - 530 nm
                   Target: ~515-520 nm for green emission

Y3_fwhm:          Full Width Half Maximum (nm)
                   Range: 12 - 60 nm
                   Target: Minimize (<25 nm for narrow emission)

Y4_quality_class_encoded: Overall quality classification
                         0 = poor (PLQY < 0.40)
                         1 = fair (PLQY 0.40-0.60)  
                         2 = good (PLQY 0.60-0.75)
                         3 = excellent (PLQY > 0.75)

SYNTHESIS RELATIONSHIPS:
-----------------------
- Higher Cs:Pb ratio (X1/X2) generally improves PLQY up to ~1.2
- Temperature window 130-170Â°C optimal for high PLQY
- Residence time 80-180s typically optimal (temperature dependent)
- Total flow rate affects mixing and residence time distribution

COMMERCIAL TARGETS:
------------------
- PLQY > 80% (Y1 > 0.80)
- Green emission 515-520nm (Y2 = 515-520)  
- Narrow linewidth FWHM < 25nm (Y3 < 25)
- Consistent quality class 2-3 (Y4 â‰¥ 2)
"""
        
        with open(filename, 'w') as f:
            f.write(dictionary)
        
        print(f"ğŸ“– Created data dictionary: {filename}")
    
    def generate_summary_report(self, df):
        """
        Generate a comprehensive summary of the formatted dataset
        """
        print("\n" + "="*60)
        print("DATASET SUMMARY REPORT")
        print("="*60)
        
        print(f"\nğŸ“Š Dataset Shape: {df.shape[0]} samples Ã— {df.shape[1]} features")
        
        # X features summary
        print(f"\nğŸ” INPUT FEATURES (X):")
        x_cols = [col for col in df.columns if col.startswith('X')]
        for col in x_cols:
            print(f"   {col:25} | Min: {df[col].min():8.2f} | Max: {df[col].max():8.2f} | Mean: {df[col].mean():8.2f}")
        
        # Y targets summary  
        print(f"\nğŸ¯ OUTPUT TARGETS (Y):")
        y_cols = [col for col in df.columns if col.startswith('Y') and 'categorical' not in col]
        for col in y_cols:
            if 'encoded' in col:
                print(f"   {col:25} | Classes: {sorted(df[col].unique())}")
            else:
                print(f"   {col:25} | Min: {df[col].min():8.3f} | Max: {df[col].max():8.3f} | Mean: {df[col].mean():8.3f}")
        
        # Quality distribution
        if 'Y4_quality_class_categorical' in df.columns:
            print(f"\nğŸ“ˆ Quality Class Distribution:")
            quality_counts = df['Y4_quality_class_categorical'].value_counts()
            for quality, count in quality_counts.items():
                percentage = (count / len(df)) * 100
                print(f"   {quality:10}: {count:4d} samples ({percentage:5.1f}%)")
        
        # High-quality samples
        if 'Y1_plqy' in df.columns:
            high_quality = df[df['Y1_plqy'] > 0.75]
            print(f"\nâ­ High-Quality Samples (PLQY > 75%): {len(high_quality)} ({len(high_quality)/len(df)*100:.1f}%)")
            
            if len(high_quality) > 0:
                print(f"   Average PLQY: {high_quality['Y1_plqy'].mean():.3f}")
                print(f"   Average Emission: {high_quality['Y2_emission_peak'].mean():.1f} nm")
                print(f"   Average FWHM: {high_quality['Y3_fwhm'].mean():.1f} nm")

def main():
    """
    Main function to convert generated data to formatted CSV
    """
    print("ğŸ§ª CsPbBr3 Dataset CSV Formatter")
    print("=" * 40)
    
    # Initialize formatter
    formatter = CsPbBr3DatasetFormatter()
    
    # Load the generated dataset
    print("\n1ï¸âƒ£ Loading generated dataset...")
    df = formatter.load_generated_data('my_training_data_2000.csv')
    
    if df is None:
        print("âŒ Cannot proceed without data. Please run the data generator first.")
        return
    
    # Create formatted CSV with clear X/Y labels
    print("\n2ï¸âƒ£ Creating formatted ML dataset...")
    formatted_df = formatter.create_ml_formatted_csv(df, 'cspbbr3_ml_dataset.csv')
    
    # Create separate X and Y files
    print("\n3ï¸âƒ£ Creating separate X and Y files...")
    X_df, Y_df = formatter.create_separate_xy_files(df, 'cspbbr3')
    
    # Create data dictionary
    print("\n4ï¸âƒ£ Creating data dictionary...")
    formatter.create_data_dictionary('cspbbr3_data_dictionary.txt')
    
    # Generate summary report
    print("\n5ï¸âƒ£ Generating summary report...")
    formatter.generate_summary_report(formatted_df)
    
    print(f"\nâœ… Dataset formatting complete!")
    print(f"ğŸ“ Files created:")
    print(f"   â€¢ cspbbr3_ml_dataset.csv      (Combined X+Y)")
    print(f"   â€¢ cspbbr3_X_features.csv      (Input features only)")  
    print(f"   â€¢ cspbbr3_Y_targets.csv       (Output targets only)")
    print(f"   â€¢ cspbbr3_data_dictionary.txt (Column explanations)")
    
    return formatted_df, X_df, Y_df

if __name__ == "__main__":
    # Run the formatter
    formatted_df, X_df, Y_df = main()
    
    # Display sample of formatted data
    print(f"\nğŸ“‹ Sample of formatted dataset:")
    print(formatted_df.head())